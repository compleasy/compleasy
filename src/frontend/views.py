from django.shortcuts import render, redirect, get_object_or_404
from django.http import HttpResponse, JsonResponse, Http404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.contrib.auth.forms import PasswordChangeForm
from django.contrib.auth import update_session_auth_hash
from django.views.decorators.csrf import csrf_protect
from django.db.models import Q, F, Count
from django.core.paginator import Paginator
from django.conf import settings
from api.models import Device, FullReport, DiffReport, LicenseKey, PolicyRule, PolicyRuleset, Organization
from api.utils.lynis_report import LynisReport
from api.utils.compliance import check_device_compliance
from api.utils.license_utils import generate_license_key
from .forms import PolicyRulesetForm, PolicyRuleForm, DeviceForm, LicenseKeyForm, UserProfileForm
import os
import json
import logging
import re
from urllib.parse import urlparse
from django.urls import reverse
from datetime import datetime
from weasyprint import HTML
from django.template.loader import render_to_string

def safe_redirect(request, fallback_url_name='device_list', **kwargs):
    referer = request.META.get('HTTP_REFERER')
    if referer:
        parsed = urlparse(referer)
        if parsed.netloc == request.get_host():
            return redirect(referer)
    try:
        return redirect(reverse(fallback_url_name, kwargs=kwargs) if kwargs else reverse(fallback_url_name))
    except Exception:
        return redirect('device_list')

@login_required
def index(request):
    """Index view: redirect to the device list"""
    return redirect('device_list')


@login_required
@csrf_protect
def profile(request):
    """Allow authenticated users to manage their profile and password."""
    def _style_password_form(form):
        for field in form.fields.values():
            field.widget.attrs.update({
                'class': 'mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-gray-800',
            })
        if 'new_password1' in form.fields:
            form.fields['new_password1'].help_text = ''

    profile_form = UserProfileForm(instance=request.user)
    password_form = PasswordChangeForm(request.user)
    _style_password_form(password_form)

    if request.method == 'POST':
        form_type = request.POST.get('form_type', 'profile')

        if form_type == 'password':
            password_form = PasswordChangeForm(request.user, request.POST)
            _style_password_form(password_form)
            if password_form.is_valid():
                user = password_form.save()
                update_session_auth_hash(request, user)
                messages.success(request, 'Password updated successfully.')
                return redirect('profile')
            messages.error(request, 'Please correct the errors below to update your password.')
        else:
            profile_form = UserProfileForm(request.POST, instance=request.user)
            if profile_form.is_valid():
                profile_form.save()
                messages.success(request, 'Profile information updated successfully.')
                return redirect('profile')
            messages.error(request, 'Please correct the errors below to update your profile.')
            # Re-style password form after profile submission to preserve widgets
            password_form = PasswordChangeForm(request.user)
            _style_password_form(password_form)

    return render(request, 'profile/profile.html', {
        'profile_form': profile_form,
        'password_form': password_form,
    })

@login_required
def onboarding(request):
    """Onboarding view: show when no devices are found to help the user to enroll a new device"""
    import json
    # Use Lynis API URL for enrollment commands
    lynis_api_url = settings.TRIKUSEC_LYNIS_API_URL
    #TODO: allow license management. By now, we just get the last license key from the user
    user_license = LicenseKey.objects.filter(created_by=request.user).last()
    if not user_license:
        return HttpResponse('No license key found', status=404)
    
    user_licensekey = user_license.licensekey
    
    # Get all autogenerated license names to calculate next number
    autogenerated_licenses = LicenseKey.objects.filter(
        name__startswith='Autogenerated license-key'
    ).values_list('name', flat=True)
    
    return render(request, 'onboarding.html', {
        'trikusec_url': lynis_api_url,
        'licensekey': user_licensekey,
        'autogenerated_license_names': json.dumps(list(autogenerated_licenses))
    })

@login_required
def device_list(request):
    """Device list view: show all devices"""
    devices = Device.objects.all()
    if not devices:
        return redirect('onboarding')

    for device in devices:
        logging.debug('Checking compliance for device %s', device)
        
        # Get the latest report for the device
        report = FullReport.objects.filter(device=device).order_by('-created_at').first()
        if not report:
            logging.error('No report found for device %s', device)
            device.compliant = False
            device.save()
            continue
        
        report = LynisReport(report.full_report)
        
        # Use utility function to check compliance
        compliant, _ = check_device_compliance(device, report)
        device.compliant = compliant
        device.save()
    
    # Order devices by last updated (most recent first)
    devices = devices.order_by('-last_update')

    return render(request, 'device_list.html', {'devices': devices})

@login_required
def device_detail(request, device_id):
    """Device detail view: show the details of a device"""
    device = Device.objects.get(id=device_id)
    
    # Get last report for the device
    report = FullReport.objects.filter(device=device).order_by('-created_at').first()

    # If no report found, error message
    if not report:
        return HttpResponse('No report found for the device', status=404)
    
    report = LynisReport(report.full_report)
    report = report.get_parsed_report()

    if not report:
        return HttpResponse('Failed to parse the report', status=500)
    
    # Use utility function to check compliance and get detailed ruleset evaluation
    compliant, evaluated_rulesets = check_device_compliance(device, report)

    # Update the device compliance status
    device.compliant = compliant

    # Get all rulesets (used to select the rulesets for the device from the side-panel)
    policy_rulesets = PolicyRuleset.objects.prefetch_related('rules').all()
    
    # Get all rules for JavaScript
    all_rules = PolicyRule.objects.all()
    
    # Serialize rulesets for JavaScript
    rulesets_data = []
    for ruleset in policy_rulesets:
        ruleset_data = {
            'id': ruleset.id,
            'name': ruleset.name,
            'description': ruleset.description,
            'created_at': ruleset.created_at.isoformat(),
            'updated_at': ruleset.updated_at.isoformat(),
            'rules': list(ruleset.rules.values('id', 'name', 'enabled', 'description', 'rule_query')),
        }
        rulesets_data.append(ruleset_data)
    
    # Serialize all rules for JavaScript
    rules_data = []
    for rule in all_rules:
        rule_data = {
            'id': rule.id,
            'name': rule.name,
            'description': rule.description,
            'rule_query': rule.rule_query,
            'enabled': rule.enabled,
            'created_at': rule.created_at.isoformat(),
            'updated_at': rule.updated_at.isoformat(),
        }
        rules_data.append(rule_data)

    return render(request, 'device_detail.html', {
        'device': device,
        'report': report,
        'evaluated_rulesets': evaluated_rulesets,
        'rulesets': policy_rulesets,
        'all_rules': all_rules,  # For rule selection sidebar template
        'rulesets_json': json.dumps(rulesets_data),
        'rules_json': json.dumps(rules_data),
    })


@login_required
@csrf_protect
def device_update(request, device_id):
    """Device update view: update the device information"""
    device = get_object_or_404(Device, id=device_id)
    if request.method == 'POST':
        form = DeviceForm(request.POST, instance=device)
        if form.is_valid():
            # Process the rulesets
            selected_rulesets = request.POST.getlist('rulesets')
            logging.debug('Selected rulesets: %s', selected_rulesets)
            device.rulesets.set(selected_rulesets)
            form.save()
            # Return to the referer page
            return safe_redirect(request, 'device_detail', device_id=device_id)
        else:
            logging.error('Form is not valid')
    else:
        # Error
        return HttpResponse('Invalid request method', status=405)

@login_required
@csrf_protect
def device_delete(request, device_id):
    """Delete a device (AJAX + fallback)"""
    if request.method == 'POST':
        device = get_object_or_404(Device, id=device_id)
        device.delete()  # CASCADE will remove associated reports
        
        # AJAX request: return JSON
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({
                'success': True,
                'message': 'Device deleted successfully'
            })
        
        # Traditional request: redirect
        return redirect('device_list')
    
    # GET request: return 405 Method Not Allowed
    return HttpResponse('Method not allowed', status=405)

@login_required
def device_export_pdf(request, device_id):
    """Export device report to PDF"""
    device = get_object_or_404(Device, id=device_id)
    
    # Get last report for the device
    full_report = FullReport.objects.filter(device=device).order_by('-created_at').first()
    
    # If no report found, error message
    if not full_report:
        return HttpResponse('No report found for the device', status=404)
    
    report = LynisReport(full_report.full_report)
    report = report.get_parsed_report()
    
    if not report or not isinstance(report, dict):
        return HttpResponse('Failed to parse the report', status=500)
    
    # Check if report has required fields (hostname is needed for filename)
    if 'hostname' not in report:
        return HttpResponse('Failed to parse the report', status=500)
    
    # Use utility function to check compliance and get detailed ruleset evaluation
    compliant, evaluated_rulesets = check_device_compliance(device, report)
    
    # Update the device compliance status
    device.compliant = compliant
    
    # Render HTML template
    html_string = render_to_string('device/device_pdf.html', {
        'device': device,
        'report': report,
        'evaluated_rulesets': evaluated_rulesets,
        'generated_at': datetime.now(),
    }, request=request)
    
    # Generate PDF using WeasyPrint
    # Use base_url to resolve any relative URLs in the template
    html = HTML(string=html_string, base_url=request.build_absolute_uri('/'))
    document = html.render()
    pdf_bytes = document.write_pdf()
    
    # Create filename with timestamp
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f'device-{report["hostname"]}-{timestamp}.pdf'
    
    # Return PDF as response
    response = HttpResponse(pdf_bytes, content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    return response

@login_required
def device_report(request, device_id):
    """Device report view: show the full report of a device"""
    device = get_object_or_404(Device, id=device_id)
    report = FullReport.objects.filter(device=device).order_by('-created_at').first()
    if not report:
        return HttpResponse('No report found for the device', status=404)
    report = LynisReport(report.full_report)

    # Get the parsed report in key=value format, one key per line
    parsed_report = report.get_parsed_report()
    parsed_report = '\n'.join([f'{key}={value}' for key, value in parsed_report.items()])
    return HttpResponse(parsed_report, content_type='text/plain')

@login_required
def device_report_changelog(request, device_id):
    """Device report changelog view: show all the changelogs of a device"""
    device = get_object_or_404(Device, id=device_id)
    changelog = DiffReport.objects.filter(device=device).order_by('-created_at')
    if not changelog:
        return HttpResponse('No changelog found for the device', status=404)
    return HttpResponse(changelog.values_list('diff_report', flat=True), content_type='text/plain')

def enroll_sh(request):
    """Enroll view: generate enroll bash script to install the agent on a new device"""
    # Get license key from the URL
    licensekey = request.GET.get('licensekey', '').strip()
    if not licensekey:
        return HttpResponse('No license key provided', status=400)
    # Validate license key format
    if not re.match(r'^[a-zA-Z0-9_-]+$', licensekey) or len(licensekey) > 255:
        return HttpResponse('Invalid license key format', status=400)
    # Validate license key exists
    if not LicenseKey.objects.filter(licensekey=licensekey).exists():
        return HttpResponse('Invalid license key', status=401)

    # Use Lynis API URL for enrollment script
    lynis_api_url = settings.TRIKUSEC_LYNIS_API_URL
    return render(request, 'enroll.html', {'trikusec_url': lynis_api_url, 'licensekey': licensekey})

def download_lynis_custom_profile(request):
    """Generate a custom Lynis profile with the provided license key"""
    # TODO: get Lynis version from the URL, so we can generate the profile for the specific version
    lynis_version = request.GET.get('lynis_version', '2.7.5')
    if lynis_version:
        lynis_version = lynis_version.strip()
    if not re.match(r'^\d+\.\d+\.\d+$', lynis_version):
        return HttpResponse('Invalid Lynis version format', status=400)
    logging.debug('Lynis version: %s', lynis_version)

    # Get the licensekey from the URL
    licensekey = request.GET.get('licensekey', '').strip()
    if not licensekey:
        return HttpResponse('No license key provided', status=400)
    if not re.match(r'^[a-zA-Z0-9_-]+$', licensekey) or len(licensekey) > 255:
        return HttpResponse('Invalid license key format', status=400)
    if not LicenseKey.objects.filter(licensekey=licensekey).exists():
        return HttpResponse('Invalid license key', status=401)
    
    # Build server address based on Lynis API URL (without protocol)
    lynis_api_url = settings.TRIKUSEC_LYNIS_API_URL
    server_address_without_proto = lynis_api_url.split('://', 1)[1]
    trikusec_upload_server = f'{server_address_without_proto}/api/lynis'
    return render(request, 'lynis_custom_profile.html',
                    {
                      'trikusec_upload_server': trikusec_upload_server,
                      'license_key': licensekey,
                      'lynis_version': lynis_version
                    },
                    content_type='text/plain')

@login_required
def policy_list(request):
    """Unified policy list view: show all policy rulesets and rules with pagination"""
    # Pagination for rulesets (10 per page)
    ruleset_page = request.GET.get('ruleset_page', 1)
    rulesets = PolicyRuleset.objects.prefetch_related('rules', 'devices').all().order_by('-updated_at')
    ruleset_paginator = Paginator(rulesets, 10)
    rulesets_page_obj = ruleset_paginator.get_page(ruleset_page)
    
    # Pagination for rules (10 per page)
    rule_page = request.GET.get('rule_page', 1)
    rules = PolicyRule.objects.all().order_by('-updated_at')
    rule_paginator = Paginator(rules, 10)
    rules_page_obj = rule_paginator.get_page(rule_page)
    
    # Serialize rulesets for JavaScript
    rulesets_data = []
    for ruleset in rulesets:  # Use all rulesets for JavaScript, not just paginated
        ruleset_data = {
            'id': ruleset.id,
            'name': ruleset.name,
            'description': ruleset.description,
            'created_at': ruleset.created_at.isoformat(),
            'updated_at': ruleset.updated_at.isoformat(),
            'rules': list(ruleset.rules.values('id', 'name', 'enabled', 'description', 'rule_query')),
        }
        rulesets_data.append(ruleset_data)
    
    # Serialize rules for JavaScript
    rules_data = []
    for rule in rules:  # Use all rules for JavaScript, not just paginated
        rule_data = {
            'id': rule.id,
            'name': rule.name,
            'description': rule.description,
            'rule_query': rule.rule_query,
            'enabled': rule.enabled,
            'created_at': rule.created_at.isoformat(),
            'updated_at': rule.updated_at.isoformat(),
        }
        rules_data.append(rule_data)
    
    context = {
        'rulesets': rulesets_page_obj,
        'rulesets_json': json.dumps(rulesets_data),
        'rules': rules_page_obj,  # Paginated rules for the table
        'all_rules': rules,  # All rules for the rule selection sidebar
        'rules_json': json.dumps(rules_data),
    }
    
    return render(request, 'policy/policy_list.html', context)

@login_required
@csrf_protect
def ruleset_create(request):
    """Create a new policy ruleset (AJAX + fallback)"""
    if request.method == 'POST':
        # Get rules data before processing
        # Rules can come as a list (from rule selection form) or comma-separated string (from hidden field)
        rules_data = request.POST.get('rules', '')
        
        # Create form without 'rules' field - we handle it separately
        # Use only the fields we want to validate: name and description
        form = PolicyRulesetForm(request.POST)
        # Remove 'rules' from form fields to avoid validation errors
        if 'rules' in form.fields:
            form.fields.pop('rules')
        if form.is_valid():
            ruleset = form.save()
            
            # Handle rules assignment (can be list or comma-separated string)
            selected_rule_ids = []
            
            # First try getlist (for rule selection form submission)
            selected_rule_ids = request.POST.getlist('rules')
            
            # If not found, try comma-separated string from hidden field
            if not selected_rule_ids and rules_data:
                selected_rule_ids = [rules_data]
            
            # Process selected_rule_ids: split comma-separated strings and convert to integers
            processed_rule_ids = []
            for rule_id in selected_rule_ids:
                if ',' in str(rule_id):
                    # Split comma-separated string
                    processed_rule_ids.extend([rid.strip() for rid in str(rule_id).split(',') if rid.strip()])
                else:
                    processed_rule_ids.append(str(rule_id).strip())
            
            # Convert to integers and filter out invalid values
            try:
                rule_ids_int = [int(rid) for rid in processed_rule_ids if rid and rid.isdigit()]
            except (ValueError, AttributeError):
                rule_ids_int = []
            
            if rule_ids_int:
                selected_rules = PolicyRule.objects.filter(id__in=rule_ids_int)
                ruleset.rules.set(selected_rules)
                ruleset.save()
            
            # AJAX request: return JSON
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'ruleset_id': ruleset.id,
                    'message': 'Ruleset created successfully'
                })
            
            # Traditional request: redirect
            return redirect('ruleset_detail', ruleset_id=ruleset.id)
        else:
            # AJAX request: return errors
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                }, status=400)
    
    # Fallback for GET or non-AJAX POST
    return redirect('policy_list')

@login_required
def ruleset_detail(request, ruleset_id):
    """Ruleset detail view: show ruleset info, rules, and devices"""
    ruleset = get_object_or_404(PolicyRuleset, id=ruleset_id)
    
    # Get rules in this ruleset
    rules = ruleset.rules.all().order_by('name')
    
    # Get devices using this ruleset
    devices = ruleset.devices.all().order_by('hostname')
    
    # Get all rules for rule selection sidebar
    all_rules = PolicyRule.objects.all().order_by('name')
    
    # Serialize ruleset for JavaScript
    ruleset_data = {
        'id': ruleset.id,
        'name': ruleset.name,
        'description': ruleset.description,
        'created_at': ruleset.created_at.isoformat(),
        'updated_at': ruleset.updated_at.isoformat(),
        'rules': list(ruleset.rules.values('id', 'name', 'enabled', 'description', 'rule_query')),
    }
    
    # Serialize all rules for JavaScript
    rules_data = []
    for rule in all_rules:
        rule_data = {
            'id': rule.id,
            'name': rule.name,
            'description': rule.description,
            'rule_query': rule.rule_query,
            'enabled': rule.enabled,
        }
        rules_data.append(rule_data)
    
    context = {
        'ruleset': ruleset,
        'rules': rules,  # Rules in this ruleset
        'all_rules': all_rules,  # All rules for rule selection sidebar
        'devices': devices,
        'ruleset_json': json.dumps(ruleset_data),
        'rules_json': json.dumps(rules_data),
    }
    
    return render(request, 'policy/ruleset_detail.html', context)


@csrf_protect
@login_required
def ruleset_update(request, ruleset_id):
    """Update a policy ruleset (AJAX + fallback)"""
    ruleset = get_object_or_404(PolicyRuleset, id=ruleset_id)
    
    if request.method == 'POST':
        # Check if this is a rule selection form submission (only has rules, no name/description)
        selected_rule_ids = request.POST.getlist('rules')
        has_name = 'name' in request.POST
        has_description = 'description' in request.POST
        
        # If it's only rule selection (no name/description), update rules and return
        if selected_rule_ids and not has_name and not has_description:
            # Update rules assignment
            selected_rules = PolicyRule.objects.filter(id__in=selected_rule_ids)
            ruleset.rules.set(selected_rules)
            ruleset.save()
            return redirect('policy_list')
        
        # Otherwise, update ruleset details (from edit sidebar)
        # Get rules data before processing
        # Rules can come as a list (from rule selection form) or comma-separated string (from hidden field)
        rules_data = request.POST.get('rules', '')
        
        # Create form without 'rules' field - we handle it separately
        form = PolicyRulesetForm(request.POST, instance=ruleset)
        # Remove 'rules' from form fields to avoid validation errors
        if 'rules' in form.fields:
            form.fields.pop('rules')
        if form.is_valid():
            form.save()
            
            # Handle rules assignment from edit form (can be list or comma-separated string)
            selected_rule_ids = []
            
            # First try getlist (for rule selection form submission)
            selected_rule_ids = request.POST.getlist('rules')
            
            # If not found, try comma-separated string from hidden field
            if not selected_rule_ids and rules_data:
                selected_rule_ids = [rules_data]
            
            # Process selected_rule_ids: split comma-separated strings and convert to integers
            processed_rule_ids = []
            for rule_id in selected_rule_ids:
                if ',' in str(rule_id):
                    # Split comma-separated string
                    processed_rule_ids.extend([rid.strip() for rid in str(rule_id).split(',') if rid.strip()])
                else:
                    processed_rule_ids.append(str(rule_id).strip())
            
            # Convert to integers and filter out invalid values
            try:
                rule_ids_int = [int(rid) for rid in processed_rule_ids if rid and rid.isdigit()]
            except (ValueError, AttributeError):
                rule_ids_int = []
            
            if rule_ids_int:
                selected_rules = PolicyRule.objects.filter(id__in=rule_ids_int)
                ruleset.rules.set(selected_rules)
                ruleset.save()
            
            # AJAX request: return JSON
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'ruleset_id': ruleset.id,
                    'message': 'Ruleset updated successfully'
                })
            
            # Traditional request: redirect
            return redirect('ruleset_detail', ruleset_id=ruleset.id)
        else:
            # AJAX request: return errors
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                }, status=400)
    
    # Fallback for GET or non-AJAX POST
    return redirect('policy_list')

@login_required
def ruleset_add(request):
    """Policy add view: add a new policy ruleset"""
    return render(request, 'policy/ruleset_form.html')

@login_required
@csrf_protect
def ruleset_delete(request, ruleset_id):
    """Delete a policy ruleset (AJAX + fallback)"""
    if request.method == 'POST':
        policy_ruleset = get_object_or_404(PolicyRuleset, id=ruleset_id)
        policy_ruleset.delete()
        
        # AJAX request: return JSON
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({
                'success': True,
                'message': 'Ruleset deleted successfully'
            })
        
        # Traditional request: redirect
        return redirect('policy_list')
    
    # GET request: return 405 Method Not Allowed
    return HttpResponse('Method not allowed', status=405)

@login_required
@csrf_protect
def rule_delete(request, rule_id):
    """Delete a policy rule (AJAX + fallback)"""
    if request.method == 'POST':
        rule = get_object_or_404(PolicyRule, id=rule_id)
        rule.delete()
        
        # AJAX request: return JSON
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({
                'success': True,
                'message': 'Rule deleted successfully'
            })
        
        # Traditional request: redirect
        return redirect('policy_list')
    
    # GET request: return 405 Method Not Allowed
    return HttpResponse('Method not allowed', status=405)

@login_required
def rule_list(request):
    """Rule list view: show all policy rules"""
    policy_rules = PolicyRule.objects.all()
    if not policy_rules:
        return HttpResponse('No policy rules found', status=404)
    
    return render(request, 'policy/rule_list.html', {'rules': policy_rules})

@login_required
def rule_detail(request, rule_id):
    """Rule detail view: show rule info, rulesets using it"""
    rule = get_object_or_404(PolicyRule, id=rule_id)
    
    # Get rulesets using this rule (reverse relationship)
    rulesets = rule.policyruleset_set.all().order_by('name')
    
    # Serialize rule for JavaScript
    rule_data = {
        'id': rule.id,
        'name': rule.name,
        'description': rule.description,
        'rule_query': rule.rule_query,
        'enabled': rule.enabled,
        'alert': rule.alert,
        'created_at': rule.created_at.isoformat(),
        'updated_at': rule.updated_at.isoformat(),
    }
    
    context = {
        'rule': rule,
        'rulesets': rulesets,  # Rulesets using this rule
        'rule_json': json.dumps(rule_data),
    }
    
    return render(request, 'policy/rule_detail.html', context)

@login_required
@csrf_protect
def rule_update(request, rule_id):
    """Rule update view: update a policy rule (AJAX + fallback)"""
    policy_rule = get_object_or_404(PolicyRule, id=rule_id)
    
    if request.method == 'POST':
        form = PolicyRuleForm(request.POST, instance=policy_rule)
        if form.is_valid():
            form.save()
            
            # AJAX request: return JSON
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'rule_id': policy_rule.id,
                    'message': 'Rule updated successfully'
                })
            
            # Traditional request: redirect to referer or rule list
            return safe_redirect(request, 'policy_list')
    else:
            # AJAX request: return errors
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                }, status=400)
    
    # Fallback for GET or non-AJAX POST
    return redirect('policy_list')

@login_required
@csrf_protect
def rule_create(request):
    """Rule create view: create a new policy rule (AJAX + fallback)"""
    if request.method == 'POST':
        form = PolicyRuleForm(request.POST)
        if form.is_valid():
            rule = form.save()
            
            # AJAX request: return JSON
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'rule_id': rule.id,
                    'message': 'Rule created successfully'
                })
            
            # Traditional request: redirect to referer or rule list
            return safe_redirect(request, 'policy_list')
    else:
            # AJAX request: return errors
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                }, status=400)
    
    # Fallback for GET or non-AJAX POST
    return redirect('policy_list')

@login_required
def rule_add(request):
    """Rule add view: add a new policy rule"""
    return render(request, 'policy/rule_form.html')

@login_required
def rule_evaluate_for_device(request, device_id, rule_id):
    """Rule evaluation view: evaluate a rule against device's last report and return debug information"""
    device = get_object_or_404(Device, id=device_id)
    rule = get_object_or_404(PolicyRule, id=rule_id)
    
    # Get last report for the device
    full_report = FullReport.objects.filter(device=device).order_by('-created_at').first()
    
    # Always include rule info in response, even on errors
    rule_info = {
        'id': rule.id,
        'name': rule.name,
        'description': rule.description,
        'rule_query': rule.rule_query,
        'enabled': rule.enabled
    }
    
    if not full_report:
        return JsonResponse({
            'success': False,
            'error': 'No report found for the device',
            'rule': rule_info
        }, status=404)
    
    # Parse the report
    try:
        lynis_report = LynisReport(full_report.full_report)
        parsed_report = lynis_report.get_parsed_report()
    except Exception as e:
        logging.error(f'Error parsing report for device {device_id}: {e}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': f'Failed to parse the report: {str(e)}',
            'rule': rule_info
        }, status=500)
    
    if not parsed_report:
        return JsonResponse({
            'success': False,
            'error': 'Failed to parse the report',
            'rule': rule_info
        }, status=500)
    
    # Evaluate the rule with error handling
    # JMESPath handles parsing internally, so we just evaluate directly
    try:
        evaluation_result = rule.evaluate(parsed_report)
    except Exception as e:
        logging.error(f'Error evaluating rule {rule.id} for device {device_id}: {e}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': f'Error evaluating rule: {str(e)}',
            'rule': rule_info
        }, status=500)
    
    # Handle None evaluation result (evaluation failed - invalid query syntax)
    evaluation_passed = evaluation_result is True
    if evaluation_result is None:
        logging.warning(f'Rule evaluation returned None for rule {rule.id}, query: "{rule.rule_query}"')
        return JsonResponse({
            'success': False,
            'error': f'Invalid JMESPath query syntax: "{rule.rule_query}"',
            'rule': rule_info
        }, status=400)
    
    # Extract field names from the query and get their values from the report
    # This helps users see what values were actually in the report when a rule fails
    field_values = {}
    if not evaluation_passed:
        # Only extract field values when the rule fails (to help debug)
        # Extract field names from common JMESPath patterns:
        # - Simple field access: field_name
        # - Comparisons: field_name ==, field_name >, etc.
        # - Functions: contains(field_name, ...), field_name in ...
        # Pattern matches valid field names (letters, numbers, underscores, hyphens)
        field_pattern = r'\b([a-zA-Z_][a-zA-Z0-9_-]*)\b'
        # Exclude JMESPath keywords and functions
        excluded = {'contains', 'length', 'keys', 'values', 'to_string', 'to_number', 
                    'not_null', 'abs', 'avg', 'ceil', 'floor', 'max', 'min', 'sum',
                    'true', 'false', 'null', 'and', 'or', 'not'}
        
        matches = re.findall(field_pattern, rule.rule_query)
        for field_name in matches:
            if field_name not in excluded and field_name[0].isalpha():
                # Check if this looks like a field name (not a number or operator)
                if field_name in parsed_report:
                    value = parsed_report[field_name]
                    # Format the value for display
                    if isinstance(value, list):
                        field_values[field_name] = ', '.join(str(v) for v in value)
                    else:
                        field_values[field_name] = str(value)
    
    return JsonResponse({
        'success': True,
        'rule': rule_info,
        'query': rule.rule_query,
        'evaluation': {
            'result': evaluation_result,
            'passed': evaluation_passed,
            'field_values': field_values  # Only included when rule fails
        }
    })


@login_required
def activity(request):
    """Activity view: show the activity of the devices (from DiffReport)"""

    # TODO: adapt activities to the template's needs

    # My activity list with the devices and the changelog (added lines, removed lines and changed lines)
    activities = []
    max_activities = 50

    # Get all diff reports (from most recent to oldest)
    diff_reports = DiffReport.objects.all().order_by('-created_at')

    if not diff_reports:
        return HttpResponse('No activity found', status=404)
    
    # Let's humanize the diff reports to show them in the template
    for diff_report in diff_reports:
        if len(activities) >= max_activities:
            break
        
        diff = diff_report.diff_report

        # Ignore some noisy or irrelevant keys
        ignore_keys = [
            'report_datetime_start',
            'report_datetime_end',
            'slow_test',
            'uptime_in_seconds',
            'uptime_in_days',
            'deleted_file',
            'lynis_timer_next_trigger',
            'clamav_last_update',
            'tests_executed',
            'tests_skipped',
            'installed_packages_array',
            'vulnerable_package',
            'suggestion',
        ]

        lynis_diff = LynisReport.Diff(diff)
        # Generate a LynisReport object with the diff
        diff_analysis = lynis_diff.analyze(ignore_keys)

        # Check if 'added' and 'removed' keys are in the diff_analysis
        if 'added' in diff_analysis and 'removed' in diff_analysis:
            for change_type in ['added', 'removed']:
                logging.debug('Change type: %s', change_type)
                for key in diff_analysis[change_type]:
                    logging.debug('Added/removed Key: %s', key)
                    values = diff_analysis[change_type][key]
                    # Normalize to list: if it's a string, wrap it in a list
                    if not isinstance(values, list):
                        values = [values]
                    # For every value in the list of values, append a new activity

                    for value in values:
                        activities.append({
                            'device': diff_report.device,
                            'created_at': diff_report.created_at,
                            'key': key,
                            'value': value,
                            'type': change_type
                        })

        if 'changed' in diff_analysis:
            for change in diff_analysis['changed']:
                # change = {'slow_test': {'old': [['DEB-0001', '17.179738'], ['PKGS-7392', '22.329404'], ['CRYP-7902', '28.998732']], 'new': [['DEB-0001', '19.197790'], ['PKGS-7345', '11.064739'], ['PKGS-7392', '17.606281'], ['CRYP-7902', '31.913178']]}}
                key = list(change.keys())[0]
                logging.debug('Changed key: %s', key)
                
                old_value = change[key]['old']
                new_value = change[key]['new']

                activities.append({
                    'device': diff_report.device,
                    'created_at': diff_report.created_at,
                    'key': key,
                    'old_value': old_value,
                    'new_value': new_value,
                    'type': 'changed'
                })

        # Order activities by date (most recent first) and type (added, removed, changed)
        activities = sorted(activities, key=lambda x: (x['created_at'], x['type']), reverse=True)
        
    return render(request, 'activity.html', {'activities': activities})


@login_required
def license_list(request):
    """License list view: show all licenses"""
    from django.utils import timezone
    import json
    licenses = LicenseKey.objects.all().order_by('-created_at')
    
    # Serialize licenses for JavaScript
    licenses_data = []
    for license in licenses:
        licenses_data.append({
            'id': license.id,
            'name': license.name,
            'licensekey': license.licensekey,
            'max_devices': license.max_devices,
            'expires_at': license.expires_at.isoformat() if license.expires_at else None,
            'is_active': license.is_active,
        })
    
    return render(request, 'license/license_list.html', {
        'licenses': licenses,
        'licenses_json': json.dumps(licenses_data),
        'now': timezone.now()
    })


@login_required
def license_detail(request, license_id):
    """License detail view: show license details and associated devices"""
    from django.utils import timezone
    import json
    license = get_object_or_404(LicenseKey, id=license_id)
    devices = Device.objects.filter(licensekey=license).order_by('-last_update')
    trikusec_url = request.build_absolute_uri('/').rstrip('/')
    
    # Serialize license for JavaScript
    license_data = {
        'id': license.id,
        'name': license.name,
        'licensekey': license.licensekey,
        'max_devices': license.max_devices,
        'expires_at': license.expires_at.isoformat() if license.expires_at else None,
        'is_active': license.is_active,
    }
    
    return render(request, 'license/license_detail.html', {
        'license': license,
        'license_json': json.dumps(license_data),
        'devices': devices,
        'trikusec_url': trikusec_url,
        'now': timezone.now()
    })


@login_required
@csrf_protect
def license_create(request):
    """Create new license key"""
    from django.http import JsonResponse
    
    if request.method == 'POST':
        form = LicenseKeyForm(request.POST)
        if form.is_valid():
            license = form.save(commit=False)
            license.created_by = request.user
            # Generate unique license key if not provided
            if not license.licensekey:
                license.licensekey = generate_license_key()
            # Get or create default organization
            default_org, _ = Organization.objects.get_or_create(
                slug='default',
                defaults={'name': 'Default Organization', 'is_active': True}
            )
            license.organization = default_org
            license.save()
            
            # Check if this is an AJAX request
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'license_id': license.id,
                    'licensekey': license.licensekey,
                    'message': 'License created successfully'
                })
            else:
                return redirect('license_detail', license_id=license.id)
        else:
            # Check if this is an AJAX request
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                }, status=400)
    else:
        form = LicenseKeyForm()
    
    # Fallback: redirect to license list (since we removed the form template)
    return redirect('license_list')


@login_required
@csrf_protect
def license_edit(request, license_id):
    """Edit existing license"""
    from django.http import JsonResponse
    
    license = get_object_or_404(LicenseKey, id=license_id)
    if request.method == 'POST':
        form = LicenseKeyForm(request.POST, instance=license)
        if form.is_valid():
            form.save()
            
            # Check if this is an AJAX request
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'license_id': license.id,
                    'message': 'License updated successfully'
                })
            else:
                return redirect('license_detail', license_id=license.id)
        else:
            # Check if this is an AJAX request
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                }, status=400)
    else:
        form = LicenseKeyForm(instance=license)
    
    # Fallback: redirect to license detail (since we removed the form template)
    return redirect('license_detail', license_id=license.id)


@login_required
@csrf_protect
def license_delete(request, license_id):
    """Delete license (only if no devices are linked)"""
    if request.method == 'POST':
        license = get_object_or_404(LicenseKey, id=license_id)
        
        # Check if license has devices
        device_count = license.device_count()
        if device_count > 0:
            error_message = f'Cannot delete license: {device_count} device(s) are linked to this license.'
            
            # AJAX request: return JSON error
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'message': error_message
                }, status=400)
            
            # Traditional request: redirect with error message
            messages.error(request, error_message)
            return redirect('license_list')
        
        # No devices linked, safe to delete
        license.delete()
        
        # AJAX request: return JSON success
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({
                'success': True,
                'message': 'License deleted successfully'
            })
        
        # Traditional request: redirect
        return redirect('license_list')
    
    # GET request: return 405 Method Not Allowed
    return HttpResponse('Method not allowed', status=405)


@login_required
def enroll_device(request):
    """Enroll device view: show license selection interface"""
    import json
    # Use Lynis API URL for enrollment commands
    lynis_api_url = settings.TRIKUSEC_LYNIS_API_URL
    
    # Check if a specific license was selected via GET parameter
    selected_license = None
    license_id = request.GET.get('license_id')
    if license_id:
        try:
            selected_license = get_object_or_404(LicenseKey, id=license_id, created_by=request.user)
        except Http404:
            # Invalid license_id or license doesn't belong to user - ignore and continue with default
            selected_license = None
    
    # Get user's default license key (last created license)
    user_license = LicenseKey.objects.filter(created_by=request.user).last()
    if not user_license:
        return HttpResponse('No license key found', status=404)
    
    user_licensekey = user_license.licensekey
    
    # Get all autogenerated license names to calculate next number
    autogenerated_licenses = LicenseKey.objects.filter(
        name__startswith='Autogenerated license-key'
    ).values_list('name', flat=True)
    
    context = {
        'trikusec_url': lynis_api_url,
        'licensekey': user_licensekey,
        'autogenerated_license_names': json.dumps(list(autogenerated_licenses)),
        'selected_license': selected_license
    }
    
    return render(request, 'license/enroll_device.html', context)